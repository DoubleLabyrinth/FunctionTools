#include "Base64.h"

BYTE Base64Decoding::InverseBase64Table[256] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0x3F,
                                                0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF,
                                                0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
                                                0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
                                                0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

BYTE Base64Decoding::URL_Filename_Safe_InverseBase64Table[256] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF,
                                                                  0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF,
                                                                  0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
                                                                  0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
                                                                  0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
                                                                  0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

DecodedBytes Base64Decoding::GetDecodedBytes(const char* srcBase64String, UINT64 srcStringLength, bool URL_Filename_Safe) {
    DecodedBytes Ret;

    //Input is illegal when srcStringLength is not the multiple of 4 or srcBase64String is a null pointer or an empty string.
    if((srcStringLength & 0x03) || srcBase64String == nullptr || srcStringLength == 0) return Ret;

    BYTE* TransTable = URL_Filename_Safe ? URL_Filename_Safe_InverseBase64Table : InverseBase64Table;
    /*If srcStringLength is larger than 4,
     *we should check weather every character in srcBase64String except the last 8 characters is
     *between '0' ~ '9' or between 'A' ~ 'Z' or between 'a' ~ 'z' or '+' or '/'.(when URL_Filename_Safe == true, change '+' and '/' to '-' and '_')
     *If not, the input is illegal, just return a empty DecodecBytes.
     */
    if(srcStringLength > 4) {
        srcStringLength -= 4;
        for(UINT64 i = 0; i < srcStringLength; i++) if(TransTable[srcBase64String[i]] >= 0xFE) return Ret;
        srcStringLength += 4;
    }

    /*In the last 8 characters, '=' can be existed. But '=' must behind every other character.
     *That means characters behind must be '=' once '=' showed.
     */
    BYTE PaddingCount = 0;
    for(UINT64 i = srcStringLength - 4; i < srcStringLength; i++) {
        if(TransTable[srcBase64String[i]] == 0xFF) return Ret;
        if(srcBase64String[i] == '=') PaddingCount++;
    }
    for(UINT64 i = srcStringLength - PaddingCount; i < srcStringLength; i++) if(srcBase64String[i] != '=') return Ret;

    //PaddingCount could only be 0, 1 or 2. Otherwise the input is illegal.
    switch(PaddingCount) {
        case 0:
            Ret.BytesLength = (srcStringLength >> 2) * 3;
            break;
        case 1:
            if(TransTable[srcBase64String[srcStringLength - 2]] & 0x3) return Ret;
            Ret.BytesLength = (srcStringLength >> 2) * 3 - 1;
            break;
        case 2:
            if(TransTable[srcBase64String[srcStringLength - 3]] & 0x0F) return Ret;
            Ret.BytesLength = (srcStringLength >> 2) * 3 - 2;
            break;
        default:
            return Ret;
    }

    BYTE* RetBytes = (BYTE*)malloc(sizeof(BYTE) * Ret.BytesLength);
    if(RetBytes == nullptr) {
        Ret.BytesLength = 0;
        return Ret;
    }
    if(PaddingCount != 0) srcStringLength -= 4;
    UINT64 OffsetOfRetBytes = 0;
    for(UINT64 i = 0; i < srcStringLength; i += 4) {
        RetBytes[OffsetOfRetBytes] = TransTable[srcBase64String[i]] << 2 | TransTable[srcBase64String[i + 1]] >> 4;
        RetBytes[OffsetOfRetBytes + 1] = TransTable[srcBase64String[i + 1]] << 4 | TransTable[srcBase64String[i + 2]] >> 2;
        RetBytes[OffsetOfRetBytes + 2] = TransTable[srcBase64String[i + 2]] << 6 | TransTable[srcBase64String[i + 3]];
        OffsetOfRetBytes += 3;
    }

    switch(PaddingCount) {
        case 0:
            Ret.Bytes = RetBytes;
            return Ret;
        case 1:
            RetBytes[OffsetOfRetBytes] = TransTable[srcBase64String[srcStringLength]] << 2 | TransTable[srcBase64String[srcStringLength + 1]] >> 4;
            RetBytes[OffsetOfRetBytes + 1] = TransTable[srcBase64String[srcStringLength + 1]] << 4 | TransTable[srcBase64String[srcStringLength + 2]] >> 2;
            Ret.Bytes = RetBytes;
            return Ret;
        case 2:
            RetBytes[OffsetOfRetBytes] = TransTable[srcBase64String[srcStringLength]] << 2 | TransTable[srcBase64String[srcStringLength + 1]] >> 4;
            Ret.Bytes = RetBytes;
            return Ret;
        default:
            break;
    }
    free(RetBytes);
    Ret.BytesLength = 0;
    return Ret;
}
